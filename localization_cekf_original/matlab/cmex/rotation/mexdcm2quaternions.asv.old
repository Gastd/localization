/**************************************************************
 Programa: mexdcm2quaternions.c
 Objetivo: Versao Cmex de dcm2quaternions
**************************************************************/
/* A ne pas oublier: x[i][j] (Format C) <=> x[i+j*M] (Format CMEX) */

#include "mex.h"
#include <math.h>

#include "gmatrix.h"
#include "gmatrix_matlab.h"
#include "rotation.h"

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
	int		i,j;
	double  Roll, Pitch, Yaw, *pData;
	PDCM pR;
    QUATERNIONS_DECLARE(q);

	/* Verificar as entradas */
	if(nrhs!=1){
		mexErrMsgTxt("One input required.");
		}
	if(nlhs!=4){
		mexErrMsgTxt("Four outputs required.");
		}

	if ( (mxGetM(prhs[0])!=mxGetN(prhs[0])) ){
		mexErrMsgTxt("R must be square.");
	}
	if ( (mxGetM(prhs[0])!= 3) ){
		mexErrMsgTxt("R must be 3 x 3.");
	}
	/* Variaveis de entrada */
    pR = PGMATRIX_ALLOC_FROM_MXARRAY(prhs[0]);

    /* Função principal */
    rotation_dcm2quaternions(pR, &q);
    
    /* Variaveis de saida */
	plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);	pData = mxGetPr(plhs[0]);
    *pData = QUATERNIONS_Q0(q);
	plhs[1] = mxCreateDoubleMatrix(1,1,mxREAL);	pData = mxGetPr(plhs[1]);
    *pData = QUATERNIONS_Q1(q);
	plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);	pData = mxGetPr(plhs[2]);
    *pData = QUATERNIONS_Q2(q);
	plhs[2] = mxCreateDoubleMatrix(1,1,mxREAL);	pData = mxGetPr(plhs[2]);
    *pData = QUATERNIONS_Q2(q);

    PDCM_FREE(pR);
}
	
